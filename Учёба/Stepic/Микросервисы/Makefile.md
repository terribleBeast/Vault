---
tags:
  - Linux
  - TODO
---
---
Дата создания: 2025-01-06 13:02
Дата последнего изменения: 2025-01-06 13:02
---
## Основные идеи
1) 
---
*Makefile* создан для автоматизации проверки выполнения каких-либо действий (например, перекомпиляции), если в целевых файлах есть изменения. 

## Синтаксис Makefile

``` 
target: prerequisites
-> command
-> command
-> command
```

**target:** Целевые объекты - это объекты на основе, которых будет выполнена проверка необходимости выполнения команды. Если есть изменения в целевых объектах, то будут выполнены команды. (отделяются друг от друга символом пробела).

> [!NOTE] Примечание
> Первая цель выполняется по умолчанию

> [!NOTE] Примечание
> Процесс сравнения заключается в сравнении последнего изменения файла с временем...


**command** Набор команд command - это последовательно шагов, которые используются для сборки целевых файлов, которые обозначил targets. Строка команды обязательно должна начинаться с символа табуляции (в нашем случае ->).

**prerequisites** Это также имена файлов, отделенный друг от друга пробелами. Эти файлы должны существовать до того, как запустится обработка команд *targets*. Это так называемые зависимости (*dependencies*)


> [!NOTE] Проблемы перевода
> Иногда маркер цели targets называют правилом, а prerequisites - целями. Что вносит некоторую путаницу, особенно в русскоязычной документации.

## Пример 
`
``` shell
# Makefile

test: test.o
→cc test.o -o test # запустится как третье действие

test.o: test.c
→cc -c test.c -o test.o # запустится как второе действие

# Если файл test.c существует, то эта цель не выполнится. Но этот пример

# в демонстрационных целях сделан более универсальным: если файл test.c

# будет создан этой целью.

test.c:

→echo "int main() { return 0; }" > test.c # запустится как первое действие

```


> [!NOTE] Примечание
> cc более старое имя gcc. Является синонимом gcc.

При запуске make в терминале, то скомпилируется программа *test* следующей последовательностью шагов: 

1) make выберет цель *test* потому, что она первая в *Makefile*
2) цель test требует *test.o*, поэтому make ищет цель *test.o*
3) цель *test.o* требует зависимости *test.c*, поэтому make ищет цель *test.c*
4) у цели *test.c* зависимостей нет, поэтому она выполняется, то есть запускается команда *echo*, которая создаст файл *test.c*
5) Затем запустится команда `cc -c` цели *test.o* потому, что все её зависимости (*test.c*) удовлетворены.
6) Далее запустится команда `cc` цели *test* потому, что все её зависимости (*test.o*) удовлетворены.
7) В результате будет скомпилирована программа *test*.

Если удалить *test.c*, то все три цели будут перезагружены. Если вы его отрудактируете и созраниее (измените метку времени этого файла так, что она станет более поздней, чем у *test.o*), то запустятся первые две цели *test* и *test.o* (и тем самым изменяется метки у файлов *test.o* и *test*).  Если поменять метку времени у файла *test.o* (например командой touch _test.o_), то запустится заново только первая цель test. Если вы ничего не поменяете, то ни одна из целей не запустится.

### make clean

Цель clean часто используется для удаления результатов работы других целей, но не следует думать, что это какое-то специальное слово для make. Создайте следующий Makefile, и запустите для него команды make и make clean. Команда make создаст файл some_file, а команда make clean удалит его.

```
some_file:
→touch some_file

clean:
→rm -f some_file
```
Обратите внимание здесь на две новые вещи:

• Цель clean здесь не первая (она не является целью по умолчанию), и у неё нет зависимостей. Это значит, что она не запустится, пока не будет явно указана в командной строке make clean.  
• Имя цели clean не предназначено для имени файла. Если по какой-то причине вдруг появится файл с именем _clean_, то эта цель никогда не запустится, и это будет сосем не тем, что вы хотели бы получить. Далее мы рассмотрим .PHONY, что позволит решить эту проблему.

## Переменные Makefile

Переменные могут быть только строками. Для них обычно используют присваивание `:=`, но так же работает и присваивание `=`.

Пример использования переменных:

```
files := file1 file2

some_file: $(files)

→echo "Look at this variable: " $(files)
→touch some_file

file1:

→touch file1

file2:
→touch file2

clean:
→rm -f file1 file2 some_file
```

Одиночные или двойные кавычки для make ничего не значат. Они просто символы, которые присваиваются переменной. Кавычки часто полезны для шелла `bash` или `cmd`, хотя они могут вам понадобиться в командах наподобие *`printf`*. В следующем примере две команды ведут себя одинаково:
```
a := one two # эта команда установит строку a в значение "one two"

b := 'one two' # Не рекомендуется. Переменная b установится в строку"'one two'".

all:
→printf '$a'
→printf $b
```

Обращаются к переменным с помощью либо ${}, либо $(). В следующем примере происходит обращение к значению переменной x:

```
x := dude

all:
→echo $(x)
→echo ${x}

→# Плохая практика, но это работает:
→echo $x
```


> [!NOTE] Примечание
> $name_var - плохая практика

## Цели Makefile

#### Выполнение нескольких целей
Для этого даем имя цели и указываем предварительные условия. 

```
all: one two three # выполняется по умолчанию

one:
→touch one

two:
→touch two

three:
→touch three

clean:
→rm -f one two three
```

Имя цели содержится в переменной `$@`

```
all: f1.o f2.o

f1.o f2.o:
→echo $@
```

Это эквивалентно следующему:

```
f1.o:
→echo f1.o

f2.o:
→echo f2.o
```


## Примечания

#### Альтернативы make

Среди популярных систем сборки кода C/C++ можно вспомнить SCons [7], CMake [8], Bazel и Ninja. Некоторые редакторы кода наподобие Microsoft Visual Studio имеют свои встроенные инструменты сборки. Для Java это Ant, Maven и Gradle. Другие языки, такие как Go, Rust и TypeScript снабжены своими инструментами сборки.

Интерпретируемые языки, такие как Python, Ruby и чистый Javascript не требуют аналогов файлов Makefile. Цель Makefile в том, чтобы компилировать только те файлы, которые нужно перекомпилировать, основываясь на отслеживании изменения файлов. Однако когда поменялся интерпретируемый файл, то нет необходимости его перекомпилировать. Когда программа работает, всегда используется самая свежая версия интерпретируемого файла.

---
## Ресурсы:
1) [раз](https://microsin.net/programming/arm/learning-makefile-with-simple-examples.html)
2) https://stepik.org/lesson/1258996/step/1?unit=1273046
